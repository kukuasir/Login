// Code generated by go-swagger; DO NOT EDIT.

package passport

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"
	_ "github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
	"github.com/go-openapi/runtime/middleware"
	"Login/utils"
	"Login/models"
	"time"
	"fmt"
	"strconv"
)

// NrPassportSendSmsHandlerFunc turns a function with the right signature into a passport send sms handler
type NrPassportSendSmsHandlerFunc func(NrPassportSendSmsParams) middleware.Responder

// Handle executing the request and returning a response
func (fn NrPassportSendSmsHandlerFunc) Handle(params NrPassportSendSmsParams) middleware.Responder {
	return fn(params)
}

// NrPassportSendSmsHandler interface for that can handle valid passport send sms params
type NrPassportSendSmsHandler interface {
	Handle(NrPassportSendSmsParams) middleware.Responder
}

// NewNrPassportSendSms creates a new http.Handler for the passport send sms operation
func NewNrPassportSendSms(ctx *middleware.Context, handler NrPassportSendSmsHandler) *NrPassportSendSms {
	return &NrPassportSendSms{Context: ctx, Handler: handler}
}

/*NrPassportSendSms swagger:route POST /passport/sendSms Passport passportSendSms

下发短信验证码

下发短息验证码

*/
type NrPassportSendSms struct {
	Context *middleware.Context
	Handler NrPassportSendSmsHandler
}

type SMSRecord struct {
	Phone    string `json:"phone,omitempty"`
	Code     string `json:"code,omitempty"`
	CreateAt int64  `json:"create_at,omitempty"`
	Type     int64  `json:"type,omitempty"`
}

func (o *NrPassportSendSms) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		r = rCtx
	}
	var Params = NewNrPassportSendSmsParams()

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	//res := o.Handler.Handle(Params) // actually handle the request

	db, err := utils.OpenConnection()
	if err != nil {
		fmt.Println(err.Error())
	}
	defer db.Close()

	// 查找数据库内是否在5分钟内已经有短信验证码下发记录
	// 没有需要请求第三方下发短信验证码
	var record SMSRecord
	sql := "SELECT * FROM btk_SMS WHERE phone = " + *Params.Body.Phone + " AND create_at > " + strconv.FormatInt(time.Now().Unix()-utils.T_EXPIRED_SECONDS, 10)
	db.Raw(sql).Last(&record)
	if len(record.Code) == 0 {
		// 产生随机验证码
		//random := rand.New(rand.NewSource(time.Now().UnixNano()))
		//code := fmt.Sprintf("%06v", random.Int31n(1000000))
		code := "123456"
		record.Code = code
		record.Phone = *Params.Body.Phone
		record.Type = Params.Body.Type
		record.CreateAt = time.Now().Unix()
		db.Table(utils.TS_SMS).Save(&record)
	}

	var res models.State
	res.UnmarshalBinary([]byte(utils.Response200(200, "发送成功")))

	o.Context.Respond(rw, r, route.Produces, route, res)

}
