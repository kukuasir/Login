// Code generated by go-swagger; DO NOT EDIT.

package passport

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"
	_"github.com/jinzhu/gorm"
	_"github.com/jinzhu/gorm/dialects/mysql"
	"github.com/go-openapi/runtime/middleware"
	"Passport/utils"
	"Passport/models"
	"fmt"
	"time"
)

// NrPassportQuickLoginHandlerFunc turns a function with the right signature into a passport quick login handler
type NrPassportQuickLoginHandlerFunc func(NrPassportQuickLoginParams) middleware.Responder

// Handle executing the request and returning a response
func (fn NrPassportQuickLoginHandlerFunc) Handle(params NrPassportQuickLoginParams) middleware.Responder {
	return fn(params)
}

// NrPassportQuickLoginHandler interface for that can handle valid passport quick login params
type NrPassportQuickLoginHandler interface {
	Handle(NrPassportQuickLoginParams) middleware.Responder
}

// NewNrPassportQuickLogin creates a new http.Handler for the passport quick login operation
func NewNrPassportQuickLogin(ctx *middleware.Context, handler NrPassportQuickLoginHandler) *NrPassportQuickLogin {
	return &NrPassportQuickLogin{Context: ctx, Handler: handler}
}

/*NrPassportQuickLogin swagger:route POST /passport/quickLogin Passport passportQuickLogin

快捷登录接口

快捷登录接口

*/
type NrPassportQuickLogin struct {
	Context *middleware.Context
	Handler NrPassportQuickLoginHandler
}

func (o *NrPassportQuickLogin) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		r = rCtx
	}
	var Params = NewNrPassportQuickLoginParams()

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	//res := o.Handler.Handle(Params) // actually handle the request

	db, err := utils.OpenConnection()
	if err != nil {
		fmt.Println(err.Error())
	}
	defer db.Close()

	var res models.LoginState
	var state models.State
	var user models.UserBase

	var code int64
	var message string

	// 先判断验证码是否正确
	var sms SMSRecord
	db.Table(utils.T_SMS).Where("phone=?", *Params.Body.Phone).Where("code=?", *Params.Body.ValidCode).Where("type=1").Order("create_at DESC").First(&sms)
	if len(sms.Code) == 0 {
		code = 401
		message = "验证码不正确"
	} else {

		if time.Now().Unix() - utils.T_EXPIRED_SECONDS > sms.CreateAt {
			code = 402
			message = "验证码已失效"
		} else {
			// 通过短信记录获得的手机号去查询用户表，能查到说明正常登录
			db.Table(utils.T_USER).Where("phone=?", sms.Phone).Where("platform=?", utils.T_PLATFORM_QUICK_LOGIN).First(&user)
			if user.ID == 0 {

				code = 200
				message = "登录成功"

				// 第一次快捷登录，需要把信息写入到表中
				sql := "INSERT INTO btk_User(nick_name, phone, platform, login_at, register_at) VALUES(?,?,?,?,?)"
				db.Raw(sql, utils.GenNickNameBy(*Params.Body.Phone), *Params.Body.Phone, utils.T_PLATFORM_QUICK_LOGIN, time.Now().Unix(), time.Now().Unix())

				// 写完之后再查询一次，保证用户存在
				db.Table(utils.T_USER).Where("phone=?", user.Phone).First(&user)
				user.Avatar = utils.CompleteImage(user.Avatar)
				user.Euid = utils.EncryptEuid(user.ID)
				user.ID = 0
				res.Data = &user

			} else {
				if user.Status == 1 {
					code = 503
					message = "用户状态异常"
				} else {
					// 修改最后一次登录时间
					sql := "UPDATE btk_User SET login_at = ? WHERE id = ? AND status = 0"
					db.Raw(sql, time.Now().Unix(), user.ID)

					code = 200
					message = "登录成功"

					user.Avatar = utils.CompleteImage(user.Avatar)
					user.Euid = utils.EncryptEuid(user.ID)
					user.ID = 0
					res.Data = &user
				}
			}
		}
	}

	state.UnmarshalBinary([]byte(utils.Response200(code, message)))
	res.State = &state

	o.Context.Respond(rw, r, route.Produces, route, res)

}
